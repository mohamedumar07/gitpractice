- saving history of our project and go back to the date we want, when the software was working fine.

- collaborating with others

 - git allows us to maintain the project, its history, who made the change and where

 - GitHub allows us to host the git repository.

All of the history are stored in another folder, that git provides us. It's called as git repo, otherwise .git

How to know what changes are made to the project that hasn't saved yet to the history.
=>git status to check the status of the files in the project folder whether they are kept track of or not

=> git add <filename> to add all the untracked files to the staging area.

=> git commit -m <message> Recording changes to the repository.

=> git restore --staged <filename> remove the file from the staging area.

History of all the commits that were made -> git log

to go back to the commit we want and remove previous commits, we need to use "git reset <hashcode of the commit>"

git stash -> adds the modified content to backstage

git stash pop -> brings from back stage area to the non-staged area.

git stash clear -> cleans all the history in the back stage


git remote add origin <url> -> remote means working with URL, add means adding a new url, origin means the url that we are going to add. 

git remote -v -> shows all the folder that are attached to the folder.

git push origin master -> to push the changes to the master branch.


never commit on the main branch, cause that branch is used by the users.

Always create separate branches to add our changes, once they are all finalized we can add it to the main.


HEAD is a pointer which says all the commits we make added to that HEAD where it is pointing to a branch.


git branch "branch name" -> creates a new branch

git checkout <branch name> -? sets the pointer header to this branch

git merge <branch name> -> merges the branch to the main branch



